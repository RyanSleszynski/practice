Index: sorting.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>def find_min_max(list_of_items, min_or_max):\r\n    # This function will return a minimum number or maximum number depending on the second argument\r\n    # Errors will be raised if list_of_items is null or if min_or_max is NOT \"min\" or \"max\"\r\n    # A for loop and a while loop are used to show possibility of either returning correct results\r\n    index = 1\r\n    if len(list_of_items) == 0:\r\n        raise ValueError(\"Null set has no min or max\")\r\n\r\n    elif len(list_of_items) == 1:\r\n        return list_of_items[0]\r\n\r\n    elif min_or_max == \"min\":\r\n        minimum = list_of_items[0]\r\n        # For loop replaces the stored value of minimum if index_value is less than minimum\r\n        for index_value in list_of_items:\r\n            if minimum > index_value:\r\n                minimum = index_value\r\n        return minimum\r\n\r\n    elif min_or_max == \"max\":\r\n        maximum = list_of_items[0]\r\n        for index_value in list_of_items:\r\n            if maximum < index_value:\r\n                maximum = index_value\r\n            index += 1\r\n        return maximum\r\n\r\n    else:\r\n        raise ValueError(\"Second argument must be \\\"min\\\" or \\\"max\\\"\")\r\n\r\n\r\ndef is_sorted(list_of_elements, order):\r\n    # This function is faster than the is_sorted function which uses for loops instead of while\r\n    # when the passed list is not sorted.\r\n    if order == \"ascending\" or order == \"asc\":\r\n        for item_index in range(len(list_of_elements)-1):\r\n            if list_of_elements[item_index] > list_of_elements[item_index + 1]:\r\n                return False\r\n        return True\r\n\r\n    elif order == \"descending\" or order == \"desc\":\r\n        for item_index in range(len(list_of_elements) - 1):\r\n            if list_of_elements[item_index] < list_of_elements[item_index + 1]:\r\n                return False\r\n        return True\r\n\r\n\r\ndef sort_using_min_max(list_of_items, order):\r\n    # This function is about 22 times faster on average than the sort function\r\n    # This function takes the maximum or minimum in a list then adds it to a new list to be returned\r\n    # when the original passed list is empty\r\n    index = 0\r\n    if order == \"ascending\" or order == \"asc\":\r\n        ascending = []\r\n        while len(list_of_items) != 0:                         # each iteration passes a new list with the min removed\r\n            minimum = find_min_max(list_of_items, \"min\")       # finds the min in the given list\r\n            ascending.insert(index, minimum)                    # adds the min to the new list\r\n            list_of_items.remove(minimum)                      # removes the min from the given list\r\n            index += 1\r\n        return ascending\r\n\r\n    elif order == \"descending\" or order == \"desc\":\r\n        descending = []\r\n        while len(list_of_items) != 0:                         # same concept applied above to this loop as well\r\n            maximum = find_min_max(list_of_items, \"max\")\r\n            descending.insert(index, maximum)\r\n            list_of_items.remove(maximum)\r\n            index += 1\r\n        return descending\r\n\r\n    else:\r\n        raise ValueError(\"order parameter must be asc or desc\")\r\n\r\n\r\ndef bubble_sort(list_of_items, order):\r\n    # Function will return a given list in an ordered list either ascending or descending\r\n    # The flag variable remains False until the list has finished sorting\r\n    max_index = len(list_of_items) - 1\r\n    if order == \"ascending\" or order == \"asc\":\r\n        sorted_flag = False\r\n        while sorted_flag is False:\r\n            index = 0\r\n            sorted_flag = True\r\n            while index < max_index:\r\n                if list_of_items[index] > list_of_items[index + 1]:\r\n                    list_of_items[index] = list_of_items[index] ^ list_of_items[index + 1]\r\n                    list_of_items[index + 1] = list_of_items[index] ^ list_of_items[index + 1]\r\n                    list_of_items[index] = list_of_items[index] ^ list_of_items[index + 1]\r\n                    sorted_flag = False\r\n                index += 1\r\n            max_index -= 1\r\n\r\n    elif order == \"descending\" or order == \"desc\":\r\n        sorted_flag = False\r\n        while sorted_flag is False:\r\n            index = 0\r\n            sorted_flag = True\r\n            while index < max_index:\r\n                if list_of_items[index] < list_of_items[index + 1]:\r\n                    list_of_items[index] = list_of_items[index] ^ list_of_items[index + 1]\r\n                    list_of_items[index + 1] = list_of_items[index] ^ list_of_items[index + 1]\r\n                    list_of_items[index] = list_of_items[index] ^ list_of_items[index + 1]\r\n                    sorted_flag = False\r\n                index += 1\r\n            max_index -= 1\r\n    return list_of_items\r\n\r\n\r\ndef new_bubble_sort(list):\r\n    \"\"\"\r\n    This function sorts through the passed argument in ascending order. The method is: bubble sort from left to right\r\n    bringing the maximum value to the right then removing that from the comparisons because we know it is the greatest\r\n    then go from right to left moving the minimum value to the left then removing that from the comparisons because we\r\n    know it is the minimum\r\n\r\n\r\n    :param list: a list of items\r\n    :return: a sorted list in ascending order\r\n\r\n    \"\"\"\r\n    maximum_right_index = len(list) - 1\r\n    minimum_left_index = 0\r\n    while minimum_left_index < maximum_right_index:\r\n        index = minimum_left_index\r\n        while index < maximum_right_index:\r\n            if list[index] > list[index + 1]:\r\n                list[index] = list[index] ^ list[index + 1]\r\n                list[index + 1] = list[index] ^ list[index + 1]\r\n                list[index] = list[index] ^ list[index + 1]\r\n            index += 1\r\n\r\n        maximum_right_index -= 1\r\n        while index > minimum_left_index:\r\n            if list[index] < list[index - 1]:\r\n                list[index] = list[index] ^ list[index - 1]\r\n                list[index - 1] = list[index] ^ list[index - 1]\r\n                list[index] = list[index] ^ list[index - 1]\r\n            index -= 1\r\n        minimum_left_index += 1\r\n    return list\r\n\r\n\r\ndef merge(list_1, list_2, order):\r\n\r\n    list_1_index = 0\r\n    list_2_index = 0\r\n    # this temp list will be used to return the final sorted list in this function\r\n    temp_list_2 = []\r\n    if order == 'desc':\r\n        # the items in each list are being compared one by one and once\r\n        # one of the indexes reaches its respective list's end then it exits\r\n        while list_1_index < len(list_1) and list_2_index < len(list_2):\r\n            if list_1[list_1_index] > list_2[list_2_index]:\r\n                temp_list_2.append(list_1[list_1_index])\r\n                list_1_index += 1\r\n            else:\r\n                temp_list_2.append(list_2[list_2_index])\r\n                list_2_index += 1\r\n\r\n        # this if statement will append all remaining items in the list that the index is not at the end\r\n        if list_1_index == len(list_1):\r\n            for element in list_2[list_2_index:]:\r\n                temp_list_2.append(element)\r\n        else:\r\n            for element in list_1[list_1_index:]:\r\n                temp_list_2.append(element)\r\n    else:\r\n        # the items in each list are being compared one by one and once\r\n        # one of the indexes reaches its respective list's end then it exits\r\n        while list_1_index < len(list_1) and list_2_index < len(list_2):\r\n            if list_1[list_1_index] < list_2[list_2_index]:\r\n                temp_list_2.append(list_1[list_1_index])\r\n                list_1_index += 1\r\n            else:\r\n                temp_list_2.append(list_2[list_2_index])\r\n                list_2_index += 1\r\n\r\n        # this if statement will append all remaining items in the list that the index is not at the end\r\n        if list_1_index == len(list_1):\r\n            for element in list_2[list_2_index:]:\r\n                temp_list_2.append(element)\r\n        else:\r\n            for element in list_1[list_1_index:]:\r\n                temp_list_2.append(element)\r\n    return temp_list_2\r\n\r\n\r\ndef merge_sort(input_list, order: str):\r\n    temp_list = input_list[:]\r\n    # these two assignment statements split the list in half\r\n    temp_list_left = temp_list[:(len(temp_list) // 2)]\r\n    temp_list_right = temp_list[(len(temp_list) // 2):]\r\n\r\n    # If the left list has one element and the right list has more than one element\r\n    # then the right list needs to be split further\r\n    if len(temp_list_left) == 1 and len(temp_list_right) != 1:\r\n        temp_list_right = merge_sort(temp_list_right, order)\r\n\r\n    # If the right list has one element and the left list has more than one element\r\n    # then the left list needs to be split further\r\n    elif len(temp_list_left) != 1 and len(temp_list_right) == 1:\r\n        temp_list_left = merge_sort(temp_list_left, order)\r\n\r\n    # If both left and right lists have more than one element then both must be split\r\n    elif len(temp_list_left) != 1 and len(temp_list_right) != 1:\r\n        temp_list_left = merge_sort(temp_list_left, order)\r\n        temp_list_right = merge_sort(temp_list_right, order)\r\n\r\n    # Once all elements are split up into their smallest parts then this statement will run and\r\n    # go back up the stack to return the result\r\n    return merge(temp_list_left, temp_list_right, order)\r\n\r\n\r\ndef selection_sort(input_list):\r\n    temp_list = input_list[:]\r\n\r\n    # next_minimum_index represents the index of the item that is going to be the next minimum once\r\n    # that minimum is found\r\n    next_minimum_index = 0\r\n\r\n    # While the next_minimum_index is less than the length of the list then the list is not necessarily sorted yet\r\n    while next_minimum_index < len(temp_list):\r\n        # While it is not sorted. Find the next minimum that is greater than the greatest known minimum\r\n        # We assume the minimum is the next element being considered\r\n        minimum_index = next_minimum_index\r\n        # The assumed minimum_index is compared to the element immediately after it\r\n        compare_index = minimum_index + 1\r\n\r\n        # We compare the value at minimum_index to all values to the right of it to find the index of the next minimum\r\n        while compare_index < len(temp_list):\r\n            if temp_list[minimum_index] > temp_list[compare_index]:\r\n                minimum_index = compare_index\r\n            compare_index += 1\r\n\r\n        # If the next minimum element is already in the position it needs to be it does not swap\r\n        # otherwise it does swap\r\n        if minimum_index != next_minimum_index:\r\n            temp_list[next_minimum_index] = temp_list[minimum_index] ^ temp_list[next_minimum_index]\r\n            temp_list[minimum_index] = temp_list[minimum_index] ^ temp_list[next_minimum_index]\r\n            temp_list[next_minimum_index] = temp_list[minimum_index] ^ temp_list[next_minimum_index]\r\n        next_minimum_index += 1\r\n    return temp_list\r\n\r\n\r\ndef insertion_sort(input_list):\r\n\r\n    temp_list = input_list[:]\r\n\r\n    # Optimized solution below -------------------------------------------------------------------\r\n    # The next_element_index represents the item in the list that is being considered\r\n    next_element_index = 1\r\n    # When next_element_index is one greater than the length of the list then the list is sorted\r\n    while next_element_index < len(temp_list):\r\n        # index represents the element being considered but will keep track of the number as\r\n        # it moves down the list to where it belongs\r\n        index = next_element_index\r\n        # While the number before the index is greater than the element at index it will swap them\r\n        while temp_list[index - 1] > temp_list[index] and index > 0:\r\n            temp_list[index] = temp_list[index] ^ temp_list[index - 1]\r\n            temp_list[index - 1] = temp_list[index] ^ temp_list[index - 1]\r\n            temp_list[index] = temp_list[index] ^ temp_list[index - 1]\r\n            index -= 1\r\n        next_element_index += 1\r\n    return temp_list\r\n\r\n\r\ndef counting_sort(input_list):\r\n    original_list = input_list[:]\r\n    count_list = []\r\n    temp_list = input_list[:]\r\n    maximum_value = 0\r\n\r\n    # This finds the maximum value in the list, so we know how many indexes we need in the count_list\r\n    for element in original_list:\r\n        if element > maximum_value:\r\n            maximum_value = element\r\n\r\n    # This creates the proper number of indexes in count_list\r\n    while maximum_value >= 0:\r\n        count_list.append(0)\r\n        maximum_value -= 1\r\n\r\n    considered_element_index = 0\r\n    compare_index = 1\r\n\r\n    # Finds how many of the considered_element is in the list\r\n    while considered_element_index < len(original_list):  # May give an index error\r\n        if count_list[original_list[considered_element_index]] == 0:\r\n            count_of_considered_element = 1\r\n            while compare_index < len(original_list):\r\n\r\n                if original_list[considered_element_index] == original_list[compare_index]:\r\n                    count_of_considered_element += 1\r\n                compare_index += 1\r\n\r\n            count_list[original_list[considered_element_index]] = count_of_considered_element\r\n\r\n        considered_element_index += 1\r\n        compare_index = considered_element_index + 1\r\n\r\n    # This loop gets us the indexes of the values in the temp_list\r\n    count_index = 0\r\n    while count_index < len(count_list) - 1:\r\n        count_list[count_index + 1] = count_list[count_index] + count_list[count_index + 1]\r\n        count_index += 1\r\n\r\n    considered_element_index = 0\r\n    while considered_element_index < len(original_list):\r\n        temp_list[count_list[original_list[considered_element_index]] - 1] = original_list[considered_element_index]\r\n        count_list[original_list[considered_element_index]] -= 1\r\n        considered_element_index += 1\r\n\r\n    return temp_list\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    print(find_min_max([1,6,78,1,5], 'min'))
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/sorting.py b/sorting.py
--- a/sorting.py	(revision b11669ff62be7f57c7a4781112b7cb60ac2cae5e)
+++ b/sorting.py	(date 1653868354815)
@@ -2,7 +2,6 @@
     # This function will return a minimum number or maximum number depending on the second argument
     # Errors will be raised if list_of_items is null or if min_or_max is NOT "min" or "max"
     # A for loop and a while loop are used to show possibility of either returning correct results
-    index = 1
     if len(list_of_items) == 0:
         raise ValueError("Null set has no min or max")
 
@@ -22,7 +21,6 @@
         for index_value in list_of_items:
             if maximum < index_value:
                 maximum = index_value
-            index += 1
         return maximum
 
     else:
Index: search.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Searching algorithms implementations\r\nimport sorting\r\n# import misc, so we can use the is_sorted function.\r\n\r\n\r\ndef linear_search_iterative(input_list, key):\r\n    # each element in this list is being compared to the key\r\n    for element in input_list:\r\n        if element == key:\r\n            return True\r\n    return False\r\n\r\n\r\ndef binary_search_iterative(input_list, key):\r\n\r\n    min_index = 0\r\n    max_index = len(input_list) - 1\r\n\r\n    if sorting.is_sorted(input_list, 'asc'):\r\n        if key > input_list[max_index] or key < input_list[min_index]:\r\n            return False\r\n        else:\r\n            while min_index <= max_index:\r\n                mid_index = (min_index + max_index) // 2\r\n                if key == input_list[mid_index]:\r\n                    return True\r\n                elif key > input_list[mid_index]:\r\n                    min_index = mid_index + 1\r\n                elif key < input_list[mid_index]:\r\n                    max_index = mid_index - 1\r\n            return False\r\n    # else:\r\n        # raise ValueError(\"List not sorted\")\r\n\r\n\r\ndef binary_search_helper(input_list, key, min_index, mid_index, max_index):\r\n    if min_index > max_index:\r\n        return False\r\n    elif key == input_list[mid_index]:\r\n        return True\r\n    elif key > input_list[mid_index]:\r\n        return binary_search_helper(input_list, key, mid_index + 1, ((mid_index + 1) + max_index) // 2, max_index)\r\n    else:\r\n        return binary_search_helper(input_list, key, min_index, ((mid_index - 1) + min_index) // 2, mid_index - 1)\r\n\r\n\r\n\r\ndef binary_search_recursive(input_list, key):\r\n    if key > input_list[-1] or key < input_list[0]:\r\n        return False\r\n    elif sorting.is_sorted(input_list, 'asc') == True:\r\n        return binary_search_helper(input_list, key, 0, len(input_list) // 2, len(input_list) - 1)\r\n   # else:\r\n    #    raise ValueError(\"List is not sorted\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    L = [100, 86, 0, 4, 1, 27, 34, 3, 2, 97, 25, 9, 15, 99, 55]\r\n    if linear_search_iterative(L, 99):\r\n        print(\"Passed linear_search_iterative\")\r\n    else:\r\n        print('Failed')\r\n\r\n    L = sorting.merge_sort(L, 'asc')\r\n\r\n    if not binary_search_iterative(L, 85):\r\n        print(\"Passed binary_search_iterative\")\r\n    else:\r\n        print('Failed binary_search_iterative')\r\n\r\n    if not binary_search_recursive(L, 85):\r\n        print(\"Passed binary_search_recursive\")\r\n    else:\r\n        print('Failed binary_search_recursive')\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/search.py b/search.py
--- a/search.py	(revision b11669ff62be7f57c7a4781112b7cb60ac2cae5e)
+++ b/search.py	(date 1654110715368)
@@ -44,11 +44,10 @@
         return binary_search_helper(input_list, key, min_index, ((mid_index - 1) + min_index) // 2, mid_index - 1)
 
 
-
 def binary_search_recursive(input_list, key):
     if key > input_list[-1] or key < input_list[0]:
         return False
-    elif sorting.is_sorted(input_list, 'asc') == True:
+    elif sorting.is_sorted(input_list, 'asc'):
         return binary_search_helper(input_list, key, 0, len(input_list) // 2, len(input_list) - 1)
    # else:
     #    raise ValueError("List is not sorted")
Index: mathematics.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import math\r\nfrom math import sqrt\r\nimport strings_dictionaries\r\nimport sorting\r\nimport time\r\nimport sys\r\n\r\n\r\ndef is_prime(whole_number: int):\r\n    \"\"\"\r\n    Returns whether a given number is prime\r\n\r\n    :param whole_number: positive integer\r\n    :return: True if whole_number is prime, False if whole_number is NOT prime\r\n    \"\"\"\r\n\r\n    if whole_number < 0:\r\n        raise ValueError('ValueError: argument should be non-negative.')\r\n    for divisor in range(2, sqrt(whole_number).__floor__() + 1):\r\n        if whole_number % divisor == 0:\r\n            return False\r\n    return True\r\n\r\n\r\ndef is_prime_range(p, q):\r\n    \"\"\"\r\n    Returns all the prime numbers in a range of numbers\r\n\r\n    :param p: positive integer less than q\r\n    :param q: positive integer greater than p\r\n    :return: list of integers\r\n    \"\"\"\r\n\r\n    result = []\r\n    for number in range(p, q + 1):\r\n        for divisor in range(2, int(math.sqrt(number))+1):\r\n            if number % divisor == 0:\r\n                break\r\n            elif divisor > math.sqrt(number)-1:\r\n                result.append(number)\r\n\r\n    return result\r\n\r\n\r\ndef my_sum(list_of_items):\r\n    accumulator = 0\r\n    for value in list_of_items:\r\n        accumulator += value\r\n    return accumulator\r\n\r\n\r\ndef factorial(whole_number: int):\r\n    \"\"\"\r\n    Returns the factorial calculation of a given number\r\n\r\n    :param whole_number: a positive integer or zero\r\n    :return: integer\r\n    \"\"\"\r\n    # Special case\r\n    if whole_number == 0:\r\n        return 1\r\n\r\n    # This solution begins with the number given then multiplies\r\n    # by one less than the previous multiple\r\n    accumulator = whole_number\r\n    for multiple in range(whole_number - 1, 1, -1):\r\n        accumulator *= multiple\r\n    return accumulator\r\n\r\n\r\ndef combinations():\r\n    pass\r\n\r\n\r\ndef get_combos(iterable):\r\n    \"\"\"\r\n    Gets all possible combinations of an iterable using iteration.\r\n\r\n    Method description -- Starting with the last item in the iterable a single combination is made and all\r\n    subsequent combinations are based on all previously calculated combinations\r\n\r\n    :param iterable: iterable object\r\n    :return: a dictionary(hash table) of all possible combinations\r\n    \"\"\"\r\n    combo_dict = {}\r\n    for item_index in range(len(iterable)-1, -1, -1):\r\n        if len(combo_dict) >= 1:\r\n            temp = []\r\n            # This loop takes all previous entries and adds them to the current entry for later processing\r\n            for key, value in combo_dict.items():\r\n                for combo in value:\r\n                    # we are appending a tuple because of a problem with mutability of lists.\r\n                    temp.append(tuple(list(combo) + [iterable[item_index]]))\r\n            combo_dict[iterable[item_index]] = [(iterable[item_index],)] + temp\r\n\r\n            # The way this is programmed the temp list is not overwritten in memory, so we delete it here\r\n            # to free up memory\r\n            del temp\r\n        else:\r\n            combo_dict[iterable[item_index]] = [(iterable[item_index],)]\r\n    return combo_dict\r\n\r\n\r\ndef combo_sums(combo_dict, wanted_sum):\r\n    \"\"\"\r\n    Finds combinations that sum to a given number\r\n\r\n    :param  combo_dict: a dictionary of combinations where key=a value in the original iterable\r\n        value=two-dimensional iterable\r\n    :param  wanted_sum: a number you want the combinations to sum to\r\n\r\n    :returns: list of tuples\r\n    \"\"\"\r\n    possible_combinations = [combo for value in combo_dict.values() for combo in value if sum(combo) == wanted_sum]\r\n\r\n    return possible_combinations\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    input = [100,96,54,32,21,17,12,5,3,2,1]\r\n    print(f'Number of items: {len(input)}')\r\n    start = time.time()\r\n    input_combos = get_combos(input)\r\n    end = time.time()\r\n    print(f'Time taken to generate all combinations: {(end - start)} seconds')\r\n\r\n    start = time.time()\r\n    input_combo_sum = combo_sums(input_combos, 15)\r\n    end = time.time()\r\n    print(f'Time taken to find sums: {(end - start)} seconds')\r\n\r\n    for combo_num, combo in enumerate(input_combo_sum, start=1):\r\n        print(f'Combination number {combo_num}: {combo}')\r\n\r\n    # # Test Cases for is_prime-------------------------------------------------\r\n    # if not is_prime(9):\r\n    #     print(\"Passed is_prime(9)\")\r\n    # else:\r\n    #     print(\"Failed is_prime(9)\")\r\n    #\r\n    # if is_prime(2):\r\n    #     print(\"Passed is_prime(2)\")\r\n    # else:\r\n    #     print(\"Failed is_prime(2)\")\r\n    #\r\n    # Test Cases for factorial-------------------------------------------------\r\n    # if factorial(3) == 6:\r\n    #     print(\"Passed factorial\")\r\n    # else:\r\n    #     print(\"Failed factorial\", factorial(3))\r\n    #\r\n    # if factorial(5) == 120:\r\n    #     print(\"Passed factorial\")\r\n    # else:\r\n    #     print(\"Failed factorial\", factorial(5))\r\n    #\r\n    # if factorial(7) == 5040:\r\n    #     print(\"Passed factorial\")\r\n    # else:\r\n    #     print(\"Failed factorial\", factorial(7))\r\n    #\r\n    # if factorial(1) == 1:\r\n    #     print(\"Passed factorial\")\r\n    # else:\r\n    #     print(\"Failed factorial\", factorial(1))\r\n    #\r\n    # if factorial(0) == 1:\r\n    #     print(\"Passed factorial\")\r\n    # else:\r\n    #     print(\"Failed factorial\", factorial(0))\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mathematics.py b/mathematics.py
--- a/mathematics.py	(revision b11669ff62be7f57c7a4781112b7cb60ac2cae5e)
+++ b/mathematics.py	(date 1654468356255)
@@ -1,4 +1,5 @@
 import math
+import itertools
 from math import sqrt
 import strings_dictionaries
 import sorting
@@ -116,21 +117,31 @@
     return possible_combinations
 
 
+def firstn(n):
+    num = 0
+    while num < n:
+        yield num
+        num += 1
+
+
 if __name__ == "__main__":
-    input = [100,96,54,32,21,17,12,5,3,2,1]
-    print(f'Number of items: {len(input)}')
-    start = time.time()
-    input_combos = get_combos(input)
-    end = time.time()
-    print(f'Time taken to generate all combinations: {(end - start)} seconds')
-
-    start = time.time()
-    input_combo_sum = combo_sums(input_combos, 15)
-    end = time.time()
-    print(f'Time taken to find sums: {(end - start)} seconds')
-
-    for combo_num, combo in enumerate(input_combo_sum, start=1):
-        print(f'Combination number {combo_num}: {combo}')
+    # input = [100,96,54,32,21,17,12,5,3,2,1]
+    # print(f'Number of items: {len(input)}')
+    # start = time.time()
+    # input_combos = get_combos(input)
+    # end = time.time()
+    # print(f'Time taken to generate all combinations: {(end - start)} seconds')
+    #
+    # start = time.time()
+    # input_combo_sum = combo_sums(input_combos, 15)
+    # end = time.time()
+    # print(f'Time taken to find sums: {(end - start)} seconds')
+    #
+    # for combo_num, combo in enumerate(input_combo_sum, start=1):
+    #     print(f'Combination number {combo_num}: {combo}')
+    print(firstn(15).__sizeof__())
+    print([num for num in range(1,16)].__sizeof__())
+    print([num for num in range(1,16)])
 
     # # Test Cases for is_prime-------------------------------------------------
     # if not is_prime(9):
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"b01e8500-d6f5-4b93-a8d6-7e86196860cb\" name=\"Changes\" comment=\"- rewrote is_prime &#10;- rewrote get_combos to be separate inner functions&#10;- rewrote combo_sums\" />\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GithubDefaultAccount\">\r\n    <option name=\"defaultAccountId\" value=\"93b3b889-2739-4c6d-806f-7b71173ab40b\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"29RlADKNxFQN6EXLNSV5DPaXwBo\" />\r\n  <component name=\"ProjectLevelVcsManager\">\r\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\r\n  </component>\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;ASKED_ADD_EXTERNAL_FILES&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RunManager\" selected=\"Python.sorting\">\r\n    <configuration name=\"main\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"tools\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/main.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"mathematics\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"tools\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/mathematics.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"sorting\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"tools\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/sorting.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"testing\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"tools\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/testing.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python.sorting\" />\r\n        <item itemvalue=\"Python.mathematics\" />\r\n        <item itemvalue=\"Python.main\" />\r\n        <item itemvalue=\"Python.testing\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"b01e8500-d6f5-4b93-a8d6-7e86196860cb\" name=\"Changes\" comment=\"\" />\r\n      <created>1653083633499</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1653083633499</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"- fixing files\">\r\n      <created>1653083683194</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1653083683194</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"- trying to get combos to work\">\r\n      <created>1653193058771</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1653193058771</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"- trying to get combos to work\">\r\n      <created>1653330288017</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1653330288017</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"- trying to get combos to work\">\r\n      <created>1653335761757</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1653335761757</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"- completed combos but I believe it needs to be restructured\">\r\n      <created>1653529194212</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1653529194212</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00006\" summary=\"- completed combos but I believe it needs to be restructured\">\r\n      <created>1653529559761</created>\r\n      <option name=\"number\" value=\"00006\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1653529559761</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00007\" summary=\"- added a line to delete a temporary variable after each iteration of a loop because it was using too much memory&#10;- used list comprehension for possible_combinations\">\r\n      <created>1653789184255</created>\r\n      <option name=\"number\" value=\"00007\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1653789184255</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00008\" summary=\"- rewrote is_prime &#10;- rewrote get_combos to be separate inner functions&#10;- rewrote combo_sums\">\r\n      <created>1653867967165</created>\r\n      <option name=\"number\" value=\"00008\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1653867967165</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"9\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <option name=\"ADD_EXTERNAL_FILES_SILENTLY\" value=\"true\" />\r\n    <MESSAGE value=\"- fixing files\" />\r\n    <MESSAGE value=\"- trying to get combos to work\" />\r\n    <MESSAGE value=\"- completed combos but I believe it needs to be restructured\" />\r\n    <MESSAGE value=\"- added a line to delete a temporary variable after each iteration of a loop because it was using too much memory&#10;- used list comprehension for possible_combinations\" />\r\n    <MESSAGE value=\"- rewrote is_prime &#10;- rewrote get_combos to be separate inner functions&#10;- rewrote combo_sums\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"- rewrote is_prime &#10;- rewrote get_combos to be separate inner functions&#10;- rewrote combo_sums\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision b11669ff62be7f57c7a4781112b7cb60ac2cae5e)
+++ b/.idea/workspace.xml	(date 1654468595667)
@@ -1,7 +1,12 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="ChangeListManager">
-    <list default="true" id="b01e8500-d6f5-4b93-a8d6-7e86196860cb" name="Changes" comment="- rewrote is_prime &#10;- rewrote get_combos to be separate inner functions&#10;- rewrote combo_sums" />
+    <list default="true" id="b01e8500-d6f5-4b93-a8d6-7e86196860cb" name="Changes" comment="naught">
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/mathematics.py" beforeDir="false" afterPath="$PROJECT_DIR$/mathematics.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/search.py" beforeDir="false" afterPath="$PROJECT_DIR$/search.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/sorting.py" beforeDir="false" afterPath="$PROJECT_DIR$/sorting.py" afterDir="false" />
+    </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
     <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
@@ -30,6 +35,7 @@
   <component name="ProjectViewState">
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
+    <option name="showMembers" value="true" />
   </component>
   <component name="PropertiesComponent">{
   &quot;keyToString&quot;: {
@@ -38,7 +44,7 @@
     &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;
   }
 }</component>
-  <component name="RunManager" selected="Python.sorting">
+  <component name="RunManager" selected="Python.mathematics">
     <configuration name="main" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="tools" />
       <option name="INTERPRETER_OPTIONS" value="" />
@@ -125,8 +131,8 @@
     </configuration>
     <recent_temporary>
       <list>
+        <item itemvalue="Python.mathematics" />
         <item itemvalue="Python.sorting" />
-        <item itemvalue="Python.mathematics" />
         <item itemvalue="Python.main" />
         <item itemvalue="Python.testing" />
       </list>
@@ -197,7 +203,14 @@
       <option name="project" value="LOCAL" />
       <updated>1653867967165</updated>
     </task>
-    <option name="localTasksCounter" value="9" />
+    <task id="LOCAL-00009" summary="naught">
+      <created>1653868248508</created>
+      <option name="number" value="00009" />
+      <option name="presentableId" value="LOCAL-00009" />
+      <option name="project" value="LOCAL" />
+      <updated>1653868248508</updated>
+    </task>
+    <option name="localTasksCounter" value="10" />
     <servers />
   </component>
   <component name="Vcs.Log.Tabs.Properties">
@@ -218,6 +231,7 @@
     <MESSAGE value="- completed combos but I believe it needs to be restructured" />
     <MESSAGE value="- added a line to delete a temporary variable after each iteration of a loop because it was using too much memory&#10;- used list comprehension for possible_combinations" />
     <MESSAGE value="- rewrote is_prime &#10;- rewrote get_combos to be separate inner functions&#10;- rewrote combo_sums" />
-    <option name="LAST_COMMIT_MESSAGE" value="- rewrote is_prime &#10;- rewrote get_combos to be separate inner functions&#10;- rewrote combo_sums" />
+    <MESSAGE value="naught" />
+    <option name="LAST_COMMIT_MESSAGE" value="naught" />
   </component>
 </project>
\ No newline at end of file
